// Arquivo com funções para adicionar as funções de IO em assembly.

#ifndef ASM_FUNCTIONS_H
#define ASM_FUNCTIONS_H

#include <vector>
#include <string>

std::vector<std::string> add_input() {
    std::vector<std::string> input_function = {
        "readInt:",
        "enter 5,0",
        "\%define RET_ADDRS dword [ebp+8]",
        "\%define NUMBER_STREAM dword [ebp-4]",
        "\%define SIGN byte [ebp-8]",
        "mov NUMBER_STREAM, 0",
        "mov SIGN, 0",
        "push edx",
        "push ebx",
        "push ecx",
        "mov eax, 3",
        "mov ebx, 0",
        "mov ecx, __string",
        "mov edx, 12",
        "int 0x80",
        "cmp byte [__string], 0x2D",
        "jne input_positive_integer",
        "mov ecx, 1",
        "mov SIGN, 1",
        "jmp input_initialize_variables",
        "input_positive_integer:",
        "sub ecx, ecx",
        "input_initialize_variables:",
        "sub eax, eax",
        "sub edx, edx",
        "input_while:",   
        "mov dl, [__string + ecx]",
        "cmp edx, 0x0A",
        "je input_done"
        "cmp edx, 0x0D",
        "je input_done",
        "mov ebx, eax",
        "shl eax, 3",
        "add eax, ebx",
        "add eax, ebx",
        "sub dl, 0x30",
        "add eax, edx",
        "inc ecx",
        "jmp input_while",
        "input_done:",       
        "cmp SIGN, 0",
        "je input_save",
        "neg eax",
        "input_save:",
        "mov edx, RET_ADDRS",
        "mov [edx], eax",
        "mov eax, ecx",
        "pop ecx",
        "pop ebx",
        "pop edx",
        "leave",
        "ret",
    };
    return input_function;
}

std::vector<std::string> add_output(){
    std::vector<std::string> output_function = {
        "putInt:",
        "enter 0,0",
        "\%define NUMBER_SRC dword [ebp+8]",
        "push esi",
        "push ecx",
        "push edx",
        "push ebx",
        "mov esi, NUMBER_SRC",
        "mov eax, [esi]",
        "sub ecx, ecx",
        "mov ebx, 10",
        "mov byte [__string], 0",
        "cmp eax, 0",
        "jg output_is_positive",
        "je output_is_zero",
        "mov byte [__string], 0x2D",
        "inc ecx",
        "neg eax",
        "jmp output_is_positive",
        "output_is_zero:",
        "push byte 0x30",
        "inc ecx",
        "jmp output_print",
        "output_is_positive:",
        "cmp eax, 0",
        "je output_print",
        "sub edx, edx",
        "div ebx",
        "add edx, 0x30",
        "push dx",
        "inc ecx",
        "jmp output_is_positive",
        "output_print:",
        "sub ebx, ebx",
        "cmp byte [__string], 0",
        "je output_print_loop",
        "inc ebx",
        "output_print_loop:",
        "cmp ebx, ecx",
        "je output_ok_to_print",
        "pop dx",
        "mov byte [__string + ebx], dl",
        "inc ebx",
        "jmp output_print_loop",
        "output_ok_to_print:",
        "push ecx",
        "mov eax, 4",
        "mov ebx, 1",
        "mov edx, ecx",
        "mov ecx, __string",
        "int 0x80",
        "mov eax, 4",
        "mov ebx, 1",
        "mov ecx, crlf",
        "mov edx, 2",
        "int 0x80",
        "pop eax",
        "pop ebx",
        "pop edx",
        "pop ecx",
        "pop esi",
        "leave",
        "ret",
    };
    return output_function;
}

std::vector<std::string> add_hinput(){
    std::vector<std::string> hinput_function = {
        "readHex:",
        "enter 0,0",
        "%define RET_ADDRS dword [ebp+8]",
        "push ebx",
        "push ecx",
        "push edx",
        "mov eax, 3",
        "mov ebx, 0",
        "mov ecx, __string",
        "mov edx, 8",
        "int 0x80",
        "sub eax, eax",
        "sub ecx, ecx",
        "sub edx, edx",
        "decode_hex:",
        "mov dl, [__string + ecx]",
        "cmp edx, 0x0A",
        "je hinput_done",
        "cmp ecx, 8",
        "je hinput_done",
        "cmp edx, 0x39",
        "jbe is_hex_digit",
        "cmp edx, 0x5A",
        "jbe is_hex_uppercase",
        "sub dl, 0x61",
        "add dl, 10",
        "jmp hinput_loop_prep",
        "is_hex_uppercase:",
        "sub dl, 0x41",
        "add dl, 10",
        "jmp hinput_loop_prep",
        "is_hex_digit:",
        "sub dl, 0x30",
        "hinput_loop_prep:",
        "shl eax, 4",
        "add eax, edx",
        "inc ecx",
        "jmp decode_hex",
        "hinput_done:",
        "mov edx, RET_ADDRS",
        "mov [edx], eax",
        "mov eax, ecx",
        "pop ecx",
        "pop ebx",
        "pop edx",
        "leave",
        "ret",
    };
    return hinput_function;
}


#endif